package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}


init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, ENUM, CONST, READ, PRINT, RETURN, VOID, NEW, IF, ELSE, FOR;
terminal INC, PLUS, MUL, DIV, MOD, MINUS, DEC, ASSIGN, COLON, SEMI, COMMA, DOT, QUESTION;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;
terminal RELOP_EQ, RELOP_NEQ, RELOP_GT, RELOP_GE, RELOP_LT, RELOP_LE;
terminal String IDENT;
terminal Integer NUMBER, BOOL;
terminal Character CHARACTER;

nonterminal Program, ProgramName, DeclList, Decl, ConstDecl, ConstList, ConstAssign, VarDeclList, VarList, VarDecl, Var;
nonterminal EnumDecl, EnumName, EnumElemList, EnumElem;
nonterminal MethodRet, MethodList, MethodDecl, FormParamList, FormParam, ActParam, ActParamList;
nonterminal StatementList, Statement, StatementBlock, DesignatorStatement;
nonterminal ExprNoTernary;
nonterminal ForInitStatement, ForStepStatement, ForBodyStatement;
nonterminal Else, StatementThen, StatementElse;
nonterminal Assignop, Addop, Mulop, Relop;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr, CondTrueExpr, CondFalseExpr, CondFact, ForCond, AddopTermList, MulopFactorList, Literal, Factor, FactorSub, Term, Unary, Type;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, MethodName, MethodInvokeName;

precedence left ELSE;

Program ::= (Program) PROG ProgramName DeclList LBRACE MethodList RBRACE
			;

ProgramName ::=	(ProgramName) IDENT
				;

DeclList ::= 	(DeclList_list) DeclList Decl
				|
				(DeclList_e) /* epsilon */
				;
				
Decl ::=	(Decl_const) ConstDecl
			|
			(Decl_var) VarDecl
			|
			(Decl_enum) EnumDecl
			;

ConstDecl ::=	(ConstDecl) CONST Type ConstList SEMI;

ConstList ::=	(ConstList_list) ConstList COMMA ConstAssign
				|
				(ConstList_comma) ConstAssign
				;

ConstAssign ::=	(ConstAssign) IDENT ASSIGN Literal;

Literal ::= 	(Literal_n) NUMBER
				|
				(Literal_c) CHARACTER
				|
				(Literal_b) BOOL
				;

VarDecl ::= (VarDecl_var) Type VarList SEMI
			;

VarList ::= (VarList_list) VarList COMMA Var
			|
			(VarList_var) Var
			;

Var ::=	(Var_var) IDENT
		|
		(Var_arr) IDENT LBRACK RBRACK
		;
				
EnumDecl ::=	(EnumDecl) ENUM EnumName LBRACE  EnumElemList RBRACE
				;

EnumName ::=	(EnumName) IDENT
				;

EnumElemList ::= 	(EnumElemList_list) EnumElemList COMMA EnumElem
					|
					(EnumElemList_elem) EnumElem
					;

EnumElem ::=	(EnumElemExplicit) IDENT ASSIGN NUMBER
				|
				(EnumElemImplicit) IDENT
				;

Type ::=	(Type) IDENT
			;

VarDeclList ::=	(VarDeclList_list) VarDeclList VarDecl
				|
				(VarDeclList_e) /* epsilon */
				;

MethodList ::=	(MethodList_list) MethodList MethodDecl
				|
				(MethodList_e) /* epsilon */
				;
				
MethodDecl ::=	(MethodDecl) MethodRet MethodName LPAREN FormParamList RPAREN VarDeclList StatementBlock
				;
				
MethodRet ::=	(MethodRet_type) Type
				|
				(MethodRet_void) VOID
				;

MethodName ::=	(MethodName) IDENT
				;

FormParamList ::=	(FormParamList_list) FormParamList COMMA FormParam
					|
					(FormParamList_param) FormParam
					|
					(FormParamList_e) /* epsilon */
					;
					
FormParam ::=	(FormParam_var) Type IDENT
				|
				(FormParam_arr) Type IDENT LBRACK RBRACK
				;

StatementList ::= 	(StatementList_rec) StatementList Statement
				   	|										   
				  	(StatementList_e) /* epsilon */
				   	;
				   	
StatementBlock ::=	(StatementBlock) LBRACE StatementList RBRACE
					;

Statement ::=	(Statement_ds) DesignatorStatement SEMI
				|
				(Statement_if) IF LPAREN CondFact RPAREN StatementThen Else
				|
				(Statement_for) FOR LPAREN ForInitStatement SEMI ForCond SEMI ForStepStatement RPAREN ForBodyStatement
				|
				(Statement_block) StatementBlock
				|
				(Statement_return1) RETURN SEMI
		  		|
		  		(Statement_return2) RETURN Expr SEMI
			  	|
				(Statement_read) READ LPAREN Designator RPAREN SEMI
		  		|
		  		(Statement_print1) PRINT LPAREN Expr RPAREN SEMI
			  	|
				(Statement_print2) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
		  		;
		  		
Else ::=	(Else_yes) ELSE StatementElse
			|
			(Else_no) /* epsilon */
			;
			
StatementThen ::=	(StatementThen) Statement
					;
					
StatementElse ::=	(StatementElse) Statement
					;
					
ForInitStatement ::=	(ForInitStatement) DesignatorStatement
						;
			     		
ForCond ::= 	(ForCondNoRelop) ExprNoTernary
             	|
             	(ForCondRelop) ExprNoTernary Relop ExprNoTernary
             	;
             	
ForStepStatement ::=	(ForStepStatement) DesignatorStatement
						;
						
ForBodyStatement ::=	(ForBodyStatement) Statement
						;
             	
DesignatorStatement ::= (DesignatorStatement_assign) Designator Assignop Expr
						|
						(DesignatorStatement_meth) MethodInvokeName LPAREN ActParamList RPAREN
						|
						(DesignatorStatement_error) error:e
						{: parser.report_error("Oporavak od greske u DS. Linija: " + eleft, null); :}
						|
						(DesignatorStatement_inc) Designator INC
						|
						(DesignatorStatement_dec) Designator DEC
						;
						
MethodInvokeName ::=	(MethodInvokeName) IDENT;
						
Expr ::=	(Expr_noternary) ExprNoTernary
			|
			(Expr_ternary) CondFact QUESTION CondTrueExpr COLON CondFalseExpr
		 	;
		 	
ExprNoTernary ::=	(ExprNoTernary) AddopTermList;

CondTrueExpr ::=	(CondTrueExpr) Expr
					;
					
CondFalseExpr ::=	(CondFalseExpr) Expr
					;

AddopTermList ::= 	(AddopTermList_add) AddopTermList Addop Term
					|
					(AddopTermList_term) Term
					;

CondFact ::= 	(CondFactNoRelop) ExprNoTernary
             	|
             	(CondFactRelop) ExprNoTernary Relop ExprNoTernary
             	;

Term ::= (Term) MulopFactorList
		 ;

MulopFactorList ::= (MulopFactorList_mul) MulopFactorList Mulop Factor
					|
					(MulopFactorList_factor) Factor
					;
			
Factor ::=	(Factor) Unary FactorSub
			;

Unary ::= 	(Unary_m) MINUS
			|
			(Unary_e) /* epsilon */
			;

FactorSub ::= 	(FactorSub_var) Designator
				|
				(FactorSub_meth) MethodInvokeName LPAREN ActParamList RPAREN
		   		|
		   		(FactorSub_l) Literal
		   		|		   
		   		(FactorSub_new_array) NEW Type LBRACK Expr RBRACK
		   		|
		   		(FactorSub_expr) LPAREN Expr RPAREN
		   		;
		   		
Designator ::= 	(Designator_simple) IDENT
				|
				(Designator_dot) Designator DOT IDENT
				|
				(Designator_arr) Designator LBRACK Expr RBRACK
				;
				
ActParamList ::=	(ActParamList_list) ActParamList COMMA ActParam
					|
					(ActParamList_param) ActParam
					|
					(ActParamList_e) /* epsilon */
					;

ActParam ::=	(ActParam) Expr;

Assignop ::= (Assignop) ASSIGN;

Addop ::= (Addop_plus) PLUS
		  |
		  (Addop_minus) MINUS
		  ;

Mulop ::= (Mulop_mul) MUL
		  |		  
		  (Mulop_div) DIV
		  |
		  (Mulop_rem) MOD
		  ;
		  	  
Relop ::=	(Relop_eq) RELOP_EQ
			|
			(Relop_ne) RELOP_NEQ
			|
			(Relop_gt) RELOP_GT
			|
			(Relop_ge) RELOP_GE
			|
			(Relop_lt) RELOP_LT
			|
			(Relop_le) RELOP_LE
			;