package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}


init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, MAIN, ENUM, CONST, READ, PRINT, RETURN, VOID, NEW;
terminal INC, PLUS, MUL, DIV, MOD, MINUS, DEC, ASSIGN, COLON, SEMI, COMMA, DOT, QUESTION;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;
terminal RELOP_EQ, RELOP_NEQ, RELOP_GT, RELOP_GE, RELOP_LT, RELOP_LE;
terminal String IDENT;
terminal Integer NUMBER, BOOL;
terminal Character CHARACTER;

nonterminal Program, ProgramName, DeclList, Type, Decl, ConstDecl, ConstList, Constant, ConstAssign, VarDeclList, VarList, VarDecl, Var;
nonterminal EnumDecl, EnumName, EnumElemList, EnumElem;
nonterminal MainMethod, MainName, StatementList, Statement, DesignatorStatement;
nonterminal ExprNoTernary;
nonterminal Assignop, Addop, Mulop, Relop;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr, CondFact, AddopTermList, MulopFactorList, Factor, FactorSub, Term, Unary;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;


Program ::= (Program) PROG ProgramName DeclList LBRACE MainMethod RBRACE
			;

ProgramName ::=	(ProgramName) IDENT
				;

DeclList ::= 	(DeclList_list) DeclList Decl
				|
				(DeclList_e) /* epsilon */
				;
				
Decl ::=	(Decl_const) ConstDecl
			|
			(Decl_var) VarDecl
			|
			(Decl_enum) EnumDecl
			;

ConstDecl ::=	(ConstDecl) CONST Type ConstList SEMI;

ConstList ::=	(ConstList_list) ConstList COMMA ConstAssign
				|
				(ConstList_comma) ConstAssign
				;

ConstAssign ::=	(ConstAssign) IDENT ASSIGN Constant;

Constant ::= 	(Constant_n) NUMBER
				|
				(Constant_c) CHARACTER
				|
				(Constant_b) BOOL
				;

VarDecl ::= (VarDecl_var) Type VarList SEMI
			;

VarList ::= (VarList_list) VarList COMMA Var
			|
			(VarList_var) Var
			;

Var ::=	(Var_var) IDENT
		|
		(Var_arr) IDENT LBRACK RBRACK
		;
				
EnumDecl ::=	(EnumDecl) ENUM EnumName LBRACE  EnumElemList RBRACE
				;

EnumName ::=	(EnumName) IDENT
				;

EnumElemList ::= 	(EnumElemList_list) EnumElemList COMMA EnumElem
					|
					(EnumElemList_elem) EnumElem
					;

EnumElem ::=	(EnumElemExplicit) IDENT ASSIGN NUMBER
				|
				(EnumElemImplicit) IDENT
				;

Type ::=	(Type) IDENT
			;

MainMethod ::= (MainMethod) VOID MainName LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE
				;

MainName ::=	(MainName) MAIN
				;
				
VarDeclList ::=	(VarDeclList_list) VarDeclList VarDecl
				|
				(VarDeclList_e) /* epsilon */
				;

StatementList ::= 	(StatementList_rec) StatementList Statement
				   	|										   
				  	(StatementList_e) /* epsilon */
				   	;

Statement ::=	(Statement_ds) DesignatorStatement SEMI
				|
				(Statement_return1) RETURN SEMI
		  		|
		  		(Statement_return2) RETURN Expr SEMI
			  	|
				(Statement_read) READ LPAREN Designator RPAREN SEMI
		  		|
		  		(Statement_print1) PRINT LPAREN Expr RPAREN SEMI
			  	|
				(Statement_print2) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
		  		;
			     		
DesignatorStatement ::= (DesignatorStatement_assign) Designator Assignop Expr
						|
						(DesignatorStatement_error) error:e
						{: parser.report_error("Oporavak od greske u DS. Linija: " + eleft, null); :}
						|
						(DesignatorStatement_inc) Designator INC
						|
						(DesignatorStatement_dec) Designator DEC
						;
						
Expr ::=	(Expr_noternary) ExprNoTernary
			|
			(Expr_ternary) CondFact QUESTION Expr:trueExpr COLON Expr:falseExpr
		 	;
		 	
ExprNoTernary ::=	(ExprNoTernary) AddopTermList;
		 
AddopTermList ::= 	(AddopTermList_add) AddopTermList Addop Term
					|
					(AddopTermList_term) Term
					;

CondFact ::= 	(CondFactNoRelop) ExprNoTernary
             	|
             	(CondFactRelop) ExprNoTernary Relop ExprNoTernary
             	;

Term ::= (Term) MulopFactorList
		 ;

MulopFactorList ::= (MulopFactorList_mul) MulopFactorList Mulop Factor
					|
					(MulopFactorList_factor) Factor
					;
			
Factor ::=	(Factor) Unary FactorSub
			;

Unary ::= 	(Unary_m) MINUS
			|
			(Unary_e) /* epsilon */
			;

FactorSub ::= 	(FactorSub_var) Designator
		   		|
		   		(FactorSub_n) NUMBER
		   		|
		   		(FactorSub_c) CHARACTER
		   		|
		   		(FactorSub_b) BOOL
		   		|		   
		   		(FactorSub_new_array) NEW Type LBRACK Expr RBRACK
		   		|
		   		(FactorSub_expr) LPAREN Expr RPAREN
		   		;
		   		
Designator ::= 	(Designator_simple) IDENT
				|
				(Designator_dot) Designator DOT IDENT
				|
				(Designator_arr) Designator LBRACK Expr RBRACK
				;

Assignop ::= (Assignop) ASSIGN;

Addop ::= (Addop_plus) PLUS
		  |
		  (Addop_minus) MINUS
		  ;

Mulop ::= (Mulop_mul) MUL
		  |		  
		  (Mulop_div) DIV
		  |
		  (Mulop_rem) MOD
		  ;
		  	  
Relop ::=	(Relop_eq) RELOP_EQ
			|
			(Relop_ne) RELOP_NEQ
			|
			(Relop_gt) RELOP_GT
			|
			(Relop_ge) RELOP_GE
			|
			(Relop_lt) RELOP_LT
			|
			(Relop_le) RELOP_LE
			;