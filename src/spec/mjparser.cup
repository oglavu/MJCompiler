package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}


init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, ENUM, CONST, READ, PRINT, RETURN, VOID, NEW, IF, ELSE, FOR, CONTINUE, BREAK, SWITCH, CASE;
terminal OR, AND, INC, PLUS, MUL, DIV, MOD, MINUS, DEC, ASSIGN, COLON, SEMI, COMMA, DOT, QUESTION;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;
terminal RELOP_EQ, RELOP_NEQ, RELOP_GT, RELOP_GE, RELOP_LT, RELOP_LE;
terminal CLASS, EXTENDS, ABSTRACT, THIS;
terminal String IDENT;
terminal Integer NUMBER, BOOL;
terminal Character CHARACTER;

nonterminal Program, ProgramName, DeclList, Decl, ConstDecl, ConstList, ConstAssign, VarDeclList, VarList, VarDecl, Var;
nonterminal EnumDecl, EnumName, EnumElemList, EnumElem;
nonterminal MethodRet, MethodList, MethodDecl, FormParamList, FormParamMore, FormParam, ActParam, ActParamMore, ActParamList;
nonterminal StatementList, Statement, StatementBlock, DesignatorStatement;
nonterminal ExprNoTernary;
nonterminal SwitchExpr, CaseDeclList, CaseDecl, CaseNum;
nonterminal ForInitStatement, ForCondition, ForStepStatement, ForBodyStatement;
nonterminal Else, StatementThen, StatementElse;
nonterminal ClassDecl, ClassName, AbstractAtr, ExtendsAtr, FieldDeclList, ClassMethodBlock, ClassMethodList, ClassMethodDecl;
nonterminal Assignop, Addop, Mulop, Relop;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr, CondTrueExpr, CondFalseExpr, AddopTermList, MulopFactorList, Literal, Factor, FactorSub, Term, Unary, Type;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition, CondTermList, CondTerm, CondFactList, CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, DsgThis, DsgScopeMore, DsgArrayName, DsgScopeName, DsgScopeArrayName, DsgScopeElem, MethodName, MethodInvokeName, AbsMethodName;

precedence left ELSE;

Program ::= (Program) PROG ProgramName DeclList LBRACE MethodList RBRACE
			;

ProgramName ::=	(ProgramName) IDENT
				;

DeclList ::= 	(DeclList_list) DeclList Decl
				|
				(DeclList_e) /* epsilon */
				;
				
Decl ::=	(Decl_const) ConstDecl
			|
			(Decl_var) VarDecl
			|
			(Decl_enum) EnumDecl
			|
			(Decl_class) ClassDecl
			;

ConstDecl ::=	(ConstDecl) CONST Type ConstList SEMI;

ConstList ::=	(ConstList_list) ConstList COMMA ConstAssign
				|
				(ConstList_comma) ConstAssign
				;

ConstAssign ::=	(ConstAssign) IDENT ASSIGN Literal;

Literal ::= 	(Literal_n) NUMBER
				|
				(Literal_c) CHARACTER
				|
				(Literal_b) BOOL
				;

VarDecl ::= (VarDecl_var) Type VarList SEMI
			;

VarList ::= (VarList_list) VarList COMMA Var
			|
			(VarList_var) Var
			;

Var ::=	(Var_var) IDENT
		|
		(Var_arr) IDENT LBRACK RBRACK
		;
		
Type ::=	(Type) IDENT;

// --------------- Class ---------------

ClassDecl ::=	(ClassDecl) AbstractAtr CLASS ClassName ExtendsAtr LBRACE FieldDeclList ClassMethodBlock RBRACE;

ClassName ::=	(ClassName) IDENT;

AbstractAtr ::=	(AbstractAtr_abs) ABSTRACT
				|
				(AbstractAtr_e) /* epsilon */
				;

ExtendsAtr ::=	(ExtendsAtr_ext) EXTENDS Type
				|
				(ExtendsAtr_e) /* epsilon */
				;
				
FieldDeclList ::=	(FieldDeclList) VarDeclList;

ClassMethodBlock ::=	(ClassMethodBlock_list) LBRACE ClassMethodList RBRACE
						|
						(ClassMethodBlock_e) /* epsilon */
						;
	
ClassMethodList ::=	(ClassMethodList_list) ClassMethodList ClassMethodDecl
					|
					(ClassMethodList_e) /* epsilon */
					;

ClassMethodDecl ::=	(ClassMethodDecl_meth) MethodDecl
					|
					(ClassMethodDecl_abs) ABSTRACT MethodRet AbsMethodName LPAREN FormParamList RPAREN SEMI
					;
					
AbsMethodName ::=	(AbsMethodName) IDENT;

// --------------- Enum ---------------
				
EnumDecl ::=	(EnumDecl) ENUM EnumName LBRACE  EnumElemList RBRACE;

EnumName ::=	(EnumName) IDENT;

EnumElemList ::= 	(EnumElemList_list) EnumElemList COMMA EnumElem
					|
					(EnumElemList_elem) EnumElem
					;

EnumElem ::=	(EnumElemExplicit) IDENT ASSIGN NUMBER
				|
				(EnumElemImplicit) IDENT
				;

// --------------- Methods ---------------

MethodList ::=	(MethodList_list) MethodList MethodDecl
				|
				(MethodList_e) /* epsilon */
				;
				
MethodDecl ::=	(MethodDecl) MethodRet MethodName LPAREN FormParamList RPAREN VarDeclList StatementBlock;
				
MethodRet ::=	(MethodRet_type) Type
				|
				(MethodRet_void) VOID
				;

MethodName ::=	(MethodName) IDENT;

FormParamList ::=	(FormParamList_list) FormParam FormParamMore
					|
					(FormParamList_e) /* epsilon */
					;
					
FormParamMore ::=	(FormParamMore_list) COMMA FormParam FormParamMore
					|
					(FormParamMore_e) /* epsilon */
					;
					
FormParam ::=	(FormParam_var) Type IDENT
				|
				(FormParam_arr) Type IDENT LBRACK RBRACK
				;
				
VarDeclList ::=	(VarDeclList_list) VarDeclList VarDecl
				|
				(VarDeclList_e) /* epsilon */
				;
				
ActParamList ::=	(ActParamList_list) ActParam ActParamMore
					|
					(ActParamList_e) /* epsilon */
    				;

ActParamMore ::=	(ActParamMore_list) COMMA ActParam ActParamMore
					|
					(ActParamMore_e) /* epsilon */
    				;

ActParam ::= (ActParam) Expr;

MethodInvokeName ::=	(MethodInvokeName) Designator;

// --------------- Statement ---------------

Statement ::=	(Statement_ds) DesignatorStatement SEMI
				|
				(Statement_if) IF LPAREN Condition RPAREN StatementThen Else
				|
				(Statement_for) FOR LPAREN ForInitStatement SEMI ForCondition SEMI ForStepStatement RPAREN ForBodyStatement
				|
				(Statement_continue) CONTINUE SEMI
				|
				(Statement_break) BREAK SEMI
				|
				(Statement_switch) SWITCH LPAREN SwitchExpr RPAREN LBRACE CaseDeclList RBRACE
				|
				(Statement_block) StatementBlock
				|
				(Statement_return1) RETURN SEMI
		  		|
		  		(Statement_return2) RETURN Expr SEMI
			  	|
				(Statement_read) READ LPAREN Designator RPAREN SEMI
		  		|
		  		(Statement_print1) PRINT LPAREN Expr RPAREN SEMI
			  	|
				(Statement_print2) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
		  		;
             	
DesignatorStatement ::= (DesignatorStatement_assign) Designator Assignop Expr
						|
						(DesignatorStatement_meth) MethodInvokeName LPAREN ActParamList RPAREN
						|
						(DesignatorStatement_error) error:e
						{: parser.report_error("Oporavak od greske u DS. Linija: " + eleft, null); :}
						|
						(DesignatorStatement_inc) Designator INC
						|
						(DesignatorStatement_dec) Designator DEC
						;

StatementList ::= 	(StatementList_rec) StatementList Statement
				   	|										   
				  	(StatementList_e) /* epsilon */
				   	;
				   	
StatementBlock ::=	(StatementBlock) LBRACE StatementList RBRACE;

// --------------- Switch ---------------

SwitchExpr ::=	(SwitchExpr) Expr;
				
CaseDeclList ::=	(CaseDeclList_list) CaseDecl CaseDeclList
					|
					(CaseDeclList_e) /* epsilon */
					;
				
CaseDecl ::=	(CaseDecl) CASE CaseNum COLON StatementList;
				
CaseNum ::=	(CaseNum) NUMBER;

// --------------- If ---------------

Else ::=	(Else_yes) ELSE StatementElse
			|
			(Else_no) /* epsilon */
			;
			
StatementThen ::=	(StatementThen) Statement;
					
StatementElse ::=	(StatementElse) Statement;

// --------------- For Loop ---------------

ForInitStatement ::=	(ForInitStatement_ds) DesignatorStatement
						|
						(ForInitStatement_e) /* epsilon */
						;
			     		
ForCondition ::= 	(ForCondition_cond) Condition
					|
					(ForCondition_e) /* epsilon */
					;
             	
ForStepStatement ::=	(ForStepStatement_ds) DesignatorStatement
						|
						(ForStepStatement_e) /* epsilon */
						;
						
ForBodyStatement ::=	(ForBodyStatement) Statement;

// --------------- Condition ---------------

Condition ::=	(Condition) CondTermList;
				
CondTermList ::=	(CondTermList_list) CondTermList OR CondTerm
					|
					(CondTermList_term) CondTerm
					;
					
CondTerm ::=	(CondTerm) CondFactList;

CondFactList ::=	(CondFactList_list) CondFactList AND CondFact
					|
					(CondFactList_fact) CondFact
					;
				
CondFact ::= 	(CondFact_expr) ExprNoTernary
             	|
             	(CondFact_relop) ExprNoTernary Relop ExprNoTernary
             	;

// --------------- Expr basics ---------------
Expr ::=	(Expr_noternary) ExprNoTernary
			|
			(Expr_ternary) Condition QUESTION CondTrueExpr COLON CondFalseExpr
		 	;
		 	
CondTrueExpr ::=	(CondTrueExpr) Expr;
					
CondFalseExpr ::=	(CondFalseExpr) Expr;
		 	
ExprNoTernary ::=	(ExprNoTernary) AddopTermList;
     	
AddopTermList ::= 	(AddopTermList_add) AddopTermList Addop Term
					|
					(AddopTermList_term) Term
					;

Term ::= (Term) MulopFactorList;

MulopFactorList ::= (MulopFactorList_mul) MulopFactorList Mulop Factor
					|
					(MulopFactorList_factor) Factor
					;
			
Factor ::=	(Factor) Unary FactorSub;

Unary ::= 	(Unary_m) MINUS
			|
			(Unary_e) /* epsilon */
			;

FactorSub ::= 	(FactorSub_var) Designator
				|
				(FactorSub_meth) MethodInvokeName LPAREN ActParamList RPAREN
		   		|
		   		(FactorSub_l) Literal
		   		|		   
		   		(FactorSub_new_array) NEW Type LBRACK Expr RBRACK
		   		|
		   		(FactorSub_new) NEW Type
		   		|
		   		(FactorSub_expr) LPAREN Expr RPAREN
		   		;
		   		
Designator ::= 	(Designator_var) IDENT
				|
				(Designator_elem) DsgArrayName LBRACK Expr RBRACK
				|
				(Designator_this) DsgThis DsgScopeMore
				|
				(Designator_scope) DsgScopeName DsgScopeMore
				|
				(Designator_scope_elem) DsgScopeElem DsgScopeMore
				;
				
DsgScopeMore ::= 	(DsgScopeMore_var) DOT IDENT 
					|
					(DsgScopeMore_elem) DOT DsgScopeArrayName LBRACK Expr RBRACK 
					|
					(DsgScopeMore_scope_var) DsgScopeMore DOT IDENT
					|
					(DsgScopeMore_scope_elem) DsgScopeMore DOT DsgScopeArrayName LBRACK Expr RBRACK
					;
				
DsgThis ::= (DsgThis) THIS;
		
DsgArrayName ::=	(DsgArrayName) IDENT;

DsgScopeName ::=	(DsgScopeName) IDENT;

DsgScopeArrayName ::=	(DsgScopeArrayName) IDENT;

DsgScopeElem ::=	(DsgScopeElem) DsgArrayName LBRACK Expr RBRACK;


Assignop ::= (Assignop) ASSIGN;

Addop ::= (Addop_plus) PLUS
		  |
		  (Addop_minus) MINUS
		  ;

Mulop ::= (Mulop_mul) MUL
		  |		  
		  (Mulop_div) DIV
		  |
		  (Mulop_rem) MOD
		  ;
		  	  
Relop ::=	(Relop_eq) RELOP_EQ
			|
			(Relop_ne) RELOP_NEQ
			|
			(Relop_gt) RELOP_GT
			|
			(Relop_ge) RELOP_GE
			|
			(Relop_lt) RELOP_LT
			|
			(Relop_le) RELOP_LE
			;